<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 - Bot vs Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #776e65;
            color: #f9f6f2;
            margin: 0;
            padding: 20px;
        }

        .game-container {
            text-align: center;
            max-width: 500px;
            width: 100%;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            gap: 20px;
        }

        .info-box {
            background-color: #bbada0;
            color: #776e65;
            padding: 15px;
            border-radius: 6px;
            flex: 1;
            font-weight: bold;
        }

        .game-board {
            margin: 20px auto;
            background-color: #bbada0;
            border-radius: 6px;
            padding: 10px;
            position: relative;
        }

        .grid-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
        }

        .grid-row {
            display: flex;
        }

        .grid-cell {
            width: 90px;
            height: 90px;
            margin: 5px;
            background-color: #cdc1b4;
            border-radius: 3px;
        }

        .tile-container {
            position: relative;
            z-index: 2;
            width: 400px;
            height: 400px;
        }

        .tile {
            position: absolute;
            width: 90px;
            height: 90px;
            background-color: #eee4da;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 35px;
            font-weight: bold;
            color: #776e65;
            transition: all 0.15s ease-in-out;
            margin: 5px;
        }

        .tile-2 { background-color: #eee4da; color: #776e65; }
        .tile-4 { background-color: #ede0c8; color: #776e65; }
        .tile-8 { background-color: #f2b179; color: #f9f6f2; }
        .tile-16 { background-color: #f59563; color: #f9f6f2; }
        .tile-32 { background-color: #f67c5f; color: #f9f6f2; }
        .tile-64 { background-color: #f65e3b; color: #f9f6f2; }
        .tile-128 { background-color: #edcf72; color: #f9f6f2; font-size: 30px; }
        .tile-256 { background-color: #edcc61; color: #f9f6f2; font-size: 30px; }
        .tile-512 { background-color: #edc850; color: #f9f6f2; font-size: 30px; }
        .tile-1024 { background-color: #edc53f; color: #f9f6f2; font-size: 25px; }
        .tile-2048 { background-color: #edc22e; color: #f9f6f2; font-size: 25px; }

        .tile-new {
            animation: appear 0.2s ease-in-out;
        }

        .tile-merged {
            animation: pop 0.2s ease-in-out;
        }

        @keyframes appear {
            0% { opacity: 0; transform: scale(0); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .controls {
            margin: 20px 0;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #8f7a66;
            color: #f9f6f2;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background-color: #9f897a;
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .direction-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 200px;
            margin: 20px auto;
        }

        .direction-buttons button {
            width: 60px;
            height: 60px;
            font-size: 1.5em;
            padding: 0;
        }

        .empty-cell {
            visibility: hidden;
        }

        .status {
            font-size: 1.2em;
            margin: 10px 0;
            padding: 15px;
            background-color: #bbada0;
            color: #776e65;
            border-radius: 6px;
            font-weight: bold;
        }

        .game-mode {
            margin: 20px 0;
        }

        .game-mode select {
            padding: 8px 12px;
            font-size: 1em;
            border-radius: 3px;
            border: none;
            background-color: #bbada0;
            color: #776e65;
            font-weight: bold;
        }

        .bot-thinking {
            color: #f67c5f;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: #776e65;
            border-radius: 6px;
            z-index: 100;
        }

        .you-win {
            background-color: rgba(237, 194, 46, 0.9);
            color: #f9f6f2;
        }

        .strategy-info {
            background-color: #bbada0;
            color: #776e65;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üéØ 2048</h1>
        <h2>Bot AI Challenge</h2>

        <div class="game-mode">
            <label for="gameMode">Modo de Jogo:</label>
            <select id="gameMode">
                <option value="manual">Manual Player</option>
                <option value="bot">Bot Autom√°tico</option>
                <option value="assisted">Assistido por IA</option>
            </select>
        </div>

        <div class="game-info">
            <div class="info-box">
                <div>PONTUA√á√ÉO</div>
                <div id="score">0</div>
            </div>
            <div class="info-box">
                <div>MELHOR</div>
                <div id="bestScore">0</div>
            </div>
            <div class="info-box">
                <div>MOVIMENTOS</div>
                <div id="moves">0</div>
            </div>
        </div>

        <div class="status" id="gameStatus">
            Pressione "Novo Jogo" para come√ßar!
        </div>

        <div class="game-board">
            <div class="grid-container">
                <div class="grid-row">
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                </div>
                <div class="grid-row">
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                </div>
                <div class="grid-row">
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                </div>
                <div class="grid-row">
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                    <div class="grid-cell"></div>
                </div>
            </div>
            <div class="tile-container" id="tileContainer">
            </div>
            <div class="game-over" id="gameOver" style="display: none;">
                <div>Game Over!</div>
            </div>
        </div>

        <div class="direction-buttons">
            <div class="empty-cell"></div>
            <button onclick="move('up')" id="upBtn">‚¨ÜÔ∏è</button>
            <div class="empty-cell"></div>
            <button onclick="move('left')" id="leftBtn">‚¨ÖÔ∏è</button>
            <div class="empty-cell"></div>
            <button onclick="move('right')" id="rightBtn">‚û°Ô∏è</button>
            <div class="empty-cell"></div>
            <button onclick="move('down')" id="downBtn">‚¨áÔ∏è</button>
            <div class="empty-cell"></div>
        </div>

        <div class="controls">
            <button onclick="newGame()">üéØ Novo Jogo</button>
            <button onclick="undoMove()" id="undoBtn">‚Ü©Ô∏è Desfazer</button>
            <button onclick="getSuggestion()" id="hintBtn">üí° Sugest√£o IA</button>
            <button onclick="toggleBot()" id="botBtn">ü§ñ Auto Bot</button>
        </div>

        <div class="strategy-info">
            <strong>üß† Estrat√©gia da IA:</strong>
            <div id="strategyText">A IA usa algoritmos avan√ßados para maximizar a pontua√ß√£o</div>
            <div><strong>√öltima An√°lise:</strong> <span id="lastAnalysis">-</span></div>
        </div>

        <div style="margin-top: 30px;">
            <h3>üéÆ Como Jogar</h3>
            <p><strong>Objetivo:</strong> Combine os n√∫meros para chegar ao tile 2048!</p>
            <p><strong>Controles:</strong> Use as setas do teclado ou bot√µes para mover</p>
            <p><strong>Bot Mode:</strong> Assista a IA jogar usando estrat√©gias otimizadas</p>
        </div>
    </div>

    <script>
        const GRID_SIZE = 4;
        let board = [];
        let score = 0;
        let bestScore = localStorage.getItem('2048-best') || 0;
        let moves = 0;
        let gameActive = false;
        let gameMode = 'manual';
        let botRunning = false;
        let botThinking = false;
        let previousStates = [];

        // Elementos DOM
        const scoreElement = document.getElementById('score');
        const bestScoreElement = document.getElementById('bestScore');
        const movesElement = document.getElementById('moves');
        const statusElement = document.getElementById('gameStatus');
        const tileContainer = document.getElementById('tileContainer');
        const gameOverElement = document.getElementById('gameOver');
        const gameModeSelect = document.getElementById('gameMode');
        const strategyElement = document.getElementById('strategyText');
        const analysisElement = document.getElementById('lastAnalysis');

        // Inicializar
        bestScoreElement.textContent = bestScore;

        // Event listeners
        gameModeSelect.addEventListener('change', (e) => {
            gameMode = e.target.value;
            updateGameMode();
        });

        document.addEventListener('keydown', (e) => {
            if (!gameActive || botRunning) return;
            
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    move('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    move('right');
                    break;
            }
        });

        // Inicializar tabuleiro
        function initBoard() {
            board = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                board[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    board[i][j] = 0;
                }
            }
        }

        // Adicionar tile aleat√≥rio
        function addRandomTile() {
            const emptyCells = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j] === 0) {
                        emptyCells.push({ row: i, col: j });
                    }
                }
            }

            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                board[randomCell.row][randomCell.col] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        // Renderizar tabuleiro
        function renderBoard() {
            tileContainer.innerHTML = '';
            
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const value = board[i][j];
                    if (value !== 0) {
                        const tile = document.createElement('div');
                        tile.className = `tile tile-${value}`;
                        tile.textContent = value;
                        tile.style.top = `${i * 100}px`;
                        tile.style.left = `${j * 100}px`;
                        tileContainer.appendChild(tile);
                    }
                }
            }
        }

        // Mover tiles
        function move(direction) {
            if (!gameActive || botRunning) return;

            const previousBoard = board.map(row => [...row]);
            const previousScore = score;
            let moved = false;

            switch (direction) {
                case 'up':
                    moved = moveUp();
                    break;
                case 'down':
                    moved = moveDown();
                    break;
                case 'left':
                    moved = moveLeft();
                    break;
                case 'right':
                    moved = moveRight();
                    break;
            }

            if (moved) {
                // Salvar estado anterior
                previousStates.push({
                    board: previousBoard,
                    score: previousScore,
                    moves: moves
                });
                
                // Manter apenas √∫ltimos 10 estados
                if (previousStates.length > 10) {
                    previousStates.shift();
                }

                moves++;
                addRandomTile();
                updateDisplay();
                
                // Verificar vit√≥ria
                if (hasWon()) {
                    gameActive = false;
                    showGameOver(true);
                }
                
                // Verificar game over
                if (!canMove()) {
                    gameActive = false;
                    showGameOver(false);
                }

                // Continuar bot se ativo
                if (botRunning && gameActive) {
                    setTimeout(() => {
                        makeBotMove();
                    }, 300);
                }
            }
        }

        // Movimento para cima
        function moveUp() {
            let moved = false;
            for (let j = 0; j < GRID_SIZE; j++) {
                const column = [];
                for (let i = 0; i < GRID_SIZE; i++) {
                    if (board[i][j] !== 0) {
                        column.push(board[i][j]);
                    }
                }
                
                const newColumn = mergeArray(column);
                for (let i = 0; i < GRID_SIZE; i++) {
                    const newValue = i < newColumn.length ? newColumn[i] : 0;
                    if (board[i][j] !== newValue) {
                        moved = true;
                    }
                    board[i][j] = newValue;
                }
            }
            return moved;
        }

        // Movimento para baixo
        function moveDown() {
            let moved = false;
            for (let j = 0; j < GRID_SIZE; j++) {
                const column = [];
                for (let i = GRID_SIZE - 1; i >= 0; i--) {
                    if (board[i][j] !== 0) {
                        column.push(board[i][j]);
                    }
                }
                
                const newColumn = mergeArray(column);
                for (let i = 0; i < GRID_SIZE; i++) {
                    const newValue = i < newColumn.length ? newColumn[i] : 0;
                    const boardIndex = GRID_SIZE - 1 - i;
                    if (board[boardIndex][j] !== newValue) {
                        moved = true;
                    }
                    board[boardIndex][j] = newValue;
                }
            }
            return moved;
        }

        // Movimento para esquerda
        function moveLeft() {
            let moved = false;
            for (let i = 0; i < GRID_SIZE; i++) {
                const row = board[i].filter(cell => cell !== 0);
                const newRow = mergeArray(row);
                
                for (let j = 0; j < GRID_SIZE; j++) {
                    const newValue = j < newRow.length ? newRow[j] : 0;
                    if (board[i][j] !== newValue) {
                        moved = true;
                    }
                    board[i][j] = newValue;
                }
            }
            return moved;
        }

        // Movimento para direita
        function moveRight() {
            let moved = false;
            for (let i = 0; i < GRID_SIZE; i++) {
                const row = board[i].filter(cell => cell !== 0).reverse();
                const newRow = mergeArray(row);
                
                for (let j = 0; j < GRID_SIZE; j++) {
                    const newValue = j < newRow.length ? newRow[j] : 0;
                    const boardIndex = GRID_SIZE - 1 - j;
                    if (board[i][boardIndex] !== newValue) {
                        moved = true;
                    }
                    board[i][boardIndex] = newValue;
                }
            }
            return moved;
        }

        // Merge array
        function mergeArray(arr) {
            const result = [];
            let i = 0;
            
            while (i < arr.length) {
                if (i < arr.length - 1 && arr[i] === arr[i + 1]) {
                    // Merge
                    const merged = arr[i] * 2;
                    result.push(merged);
                    score += merged;
                    i += 2;
                } else {
                    result.push(arr[i]);
                    i++;
                }
            }
            
            return result;
        }

        // Verificar se pode mover
        function canMove() {
            // Verificar espa√ßos vazios
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j] === 0) return true;
                }
            }

            // Verificar merges poss√≠veis
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const current = board[i][j];
                    if (
                        (i < GRID_SIZE - 1 && board[i + 1][j] === current) ||
                        (j < GRID_SIZE - 1 && board[i][j + 1] === current)
                    ) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Verificar vit√≥ria
        function hasWon() {
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j] >= 2048) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Mostrar game over
        function showGameOver(won) {
            gameOverElement.style.display = 'flex';
            if (won) {
                gameOverElement.className = 'game-over you-win';
                gameOverElement.innerHTML = '<div>üèÜ Voc√™ Venceu!<br>Chegou ao 2048!</div>';
            } else {
                gameOverElement.className = 'game-over';
                gameOverElement.innerHTML = '<div>üíÄ Game Over!<br>Sem movimentos poss√≠veis</div>';
            }

            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('2048-best', bestScore);
                bestScoreElement.textContent = bestScore;
            }
        }

        // Bot AI
        function makeBotMove() {
            if (!gameActive || !botRunning) return;

            botThinking = true;
            statusElement.textContent = 'ü§ñ IA analisando movimentos...';
            statusElement.classList.add('bot-thinking');

            setTimeout(() => {
                const bestMove = getBestMove();
                if (bestMove) {
                    analysisElement.textContent = `Escolheu ${bestMove.direction} (Score: ${bestMove.score})`;
                    move(bestMove.direction);
                }
                
                botThinking = false;
                statusElement.classList.remove('bot-thinking');
                updateStatus();
            }, 500 + Math.random() * 1000);
        }

        // Obter melhor movimento
        function getBestMove() {
            const moves = ['up', 'down', 'left', 'right'];
            let bestMove = null;
            let bestScore = -1;

            for (const direction of moves) {
                const simulation = simulateMove(direction);
                if (simulation.valid) {
                    const score = evaluateBoard(simulation.board) + simulation.scoreGain;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { direction, score: Math.round(score) };
                    }
                }
            }

            return bestMove;
        }

        // Simular movimento
        function simulateMove(direction) {
            const tempBoard = board.map(row => [...row]);
            const tempScore = score;
            let moved = false;

            // Aplicar movimento tempor√°rio
            board = tempBoard;
            score = tempScore;

            switch (direction) {
                case 'up': moved = moveUp(); break;
                case 'down': moved = moveDown(); break;
                case 'left': moved = moveLeft(); break;
                case 'right': moved = moveRight(); break;
            }

            const result = {
                valid: moved,
                board: board.map(row => [...row]),
                scoreGain: score - tempScore
            };

            // Restaurar estado original
            board = tempBoard;
            score = tempScore;

            return result;
        }

        // Avaliar tabuleiro
        function evaluateBoard(boardState) {
            let score = 0;
            
            // Pontua√ß√£o por espa√ßos vazios
            const emptyCells = countEmptyCells(boardState);
            score += emptyCells * 10;

            // Pontua√ß√£o por monotonia
            score += calculateMonotonicity(boardState) * 5;

            // Pontua√ß√£o por suavidade
            score += calculateSmoothness(boardState) * 3;

            // Pontua√ß√£o por m√°ximo no canto
            const maxValue = getMaxValue(boardState);
            if (boardState[0][0] === maxValue || boardState[0][3] === maxValue ||
                boardState[3][0] === maxValue || boardState[3][3] === maxValue) {
                score += maxValue * 2;
            }

            return score;
        }

        // Contar c√©lulas vazias
        function countEmptyCells(boardState) {
            let count = 0;
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (boardState[i][j] === 0) count++;
                }
            }
            return count;
        }

        // Calcular monotonia
        function calculateMonotonicity(boardState) {
            let score = 0;
            
            // Verificar linhas
            for (let i = 0; i < GRID_SIZE; i++) {
                let increasing = 0, decreasing = 0;
                for (let j = 1; j < GRID_SIZE; j++) {
                    if (boardState[i][j] > boardState[i][j-1]) increasing++;
                    else if (boardState[i][j] < boardState[i][j-1]) decreasing++;
                }
                score += Math.min(increasing, decreasing);
            }
            
            // Verificar colunas
            for (let j = 0; j < GRID_SIZE; j++) {
                let increasing = 0, decreasing = 0;
                for (let i = 1; i < GRID_SIZE; i++) {
                    if (boardState[i][j] > boardState[i-1][j]) increasing++;
                    else if (boardState[i][j] < boardState[i-1][j]) decreasing++;
                }
                score += Math.min(increasing, decreasing);
            }
            
            return score;
        }

        // Calcular suavidade
        function calculateSmoothness(boardState) {
            let score = 0;
            
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (boardState[i][j] !== 0) {
                        // Verificar vizinhos
                        if (i < GRID_SIZE - 1 && boardState[i+1][j] !== 0) {
                            score -= Math.abs(Math.log2(boardState[i][j]) - Math.log2(boardState[i+1][j]));
                        }
                        if (j < GRID_SIZE - 1 && boardState[i][j+1] !== 0) {
                            score -= Math.abs(Math.log2(boardState[i][j]) - Math.log2(boardState[i][j+1]));
                        }
                    }
                }
            }
            
            return score;
        }

        // Obter valor m√°ximo
        function getMaxValue(boardState) {
            let max = 0;
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    max = Math.max(max, boardState[i][j]);
                }
            }
            return max;
        }

        // Novo jogo
        function newGame() {
            initBoard();
            score = 0;
            moves = 0;
            gameActive = true;
            previousStates = [];
            
            // Adicionar 2 tiles iniciais
            addRandomTile();
            addRandomTile();
            
            renderBoard();
            updateDisplay();
            updateStatus();
            
            gameOverElement.style.display = 'none';
            
            if (gameMode === 'bot') {
                startBot();
            }
        }

        // Desfazer movimento
        function undoMove() {
            if (previousStates.length === 0 || botRunning) return;
            
            const previousState = previousStates.pop();
            board = previousState.board;
            score = previousState.score;
            moves = previousState.moves;
            
            renderBoard();
            updateDisplay();
        }

        // Obter sugest√£o
        function getSuggestion() {
            if (!gameActive || botRunning) return;
            
            const suggestion = getBestMove();
            if (suggestion) {
                statusElement.textContent = `üí° Sugest√£o: Mova para ${suggestion.direction} (Score: ${suggestion.score})`;
            }
        }

        // Alternar bot
        function toggleBot() {
            if (botRunning) {
                stopBot();
            } else {
                startBot();
            }
        }

        // Iniciar bot
        function startBot() {
            if (!gameActive) return;
            
            botRunning = true;
            document.getElementById('botBtn').textContent = '‚èπÔ∏è Parar Bot';
            strategyElement.textContent = 'Bot ativo - Usando algoritmo expectiminimax otimizado';
            
            makeBotMove();
        }

        // Parar bot
        function stopBot() {
            botRunning = false;
            botThinking = false;
            document.getElementById('botBtn').textContent = 'ü§ñ Auto Bot';
            statusElement.classList.remove('bot-thinking');
            strategyElement.textContent = 'Bot parado - Modo manual ativo';
            updateStatus();
        }

        // Atualizar modo de jogo
        function updateGameMode() {
            if (gameMode === 'bot') {
                startBot();
            } else {
                stopBot();
            }
            
            const modeTexts = {
                manual: 'Modo manual - Use as setas para jogar',
                bot: 'Modo bot - IA jogando automaticamente',
                assisted: 'Modo assistido - Use a sugest√£o da IA'
            };
            
            if (!botThinking) {
                statusElement.textContent = modeTexts[gameMode];
            }
        }

        // Atualizar display
        function updateDisplay() {
            scoreElement.textContent = score;
            movesElement.textContent = moves;
            renderBoard();
        }

        // Atualizar status
        function updateStatus() {
            if (gameActive && !botThinking) {
                const modeTexts = {
                    manual: 'Use as setas do teclado ou bot√µes para mover',
                    bot: 'ü§ñ Bot jogando automaticamente',
                    assisted: 'Use a sugest√£o da IA ou jogue manualmente'
                };
                statusElement.textContent = modeTexts[gameMode];
            }
        }

        // Fun√ß√µes para automa√ß√£o externa
        window.get2048GameState = function() {
            return {
                board: board.map(row => [...row]),
                score,
                moves,
                gameActive,
                botRunning,
                botThinking,
                canMove: canMove(),
                hasWon: hasWon(),
                maxTile: getMaxValue(board)
            };
        };

        window.make2048Move = function(direction) {
            if (gameActive && !botRunning && !botThinking) {
                move(direction);
                return true;
            }
            return false;
        };

        window.get2048Analysis = function() {
            const analysis = {
                bestMove: getBestMove(),
                emptyCells: countEmptyCells(board),
                monotonicity: calculateMonotonicity(board),
                smoothness: calculateSmoothness(board),
                possibleMoves: []
            };
            
            ['up', 'down', 'left', 'right'].forEach(direction => {
                const simulation = simulateMove(direction);
                analysis.possibleMoves.push({
                    direction,
                    valid: simulation.valid,
                    scoreGain: simulation.scoreGain,
                    evaluation: simulation.valid ? evaluateBoard(simulation.board) : -1
                });
            });
            
            return analysis;
        };
    </script>
</body>
</html>